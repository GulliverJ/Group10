<html>
<head>
<title>Group 10</title>
<link rel="stylesheet" type="text/css" href="styles.css"/>
<link rel="icon" type="type/png" href="img/favicon_3.png"/>

</head>

<body>
	<div class="header">
		<div class="title" style="height: 66px">
			<img src="img/title.png"></img>
		</div>
	</div>

	<div class="wrapper">

		<div class="panel">
			<div class="nav">
				<ul class="navbar">
					<li><a = href="index.html">HOME</a></li>
					<li><a = href="mgmt.html">PROJECT MANAGEMENT</a></li>
					<br>
					<img src="img/navdivide.png"></img>
					<br>
					<br>
					<li><a = href="background.html">BACKGROUND</a></li>
					<li><a = href="requirements.html">REQUIREMENTS</a></li>
					<li><a = href="research.html">RESEARCH</a></li>
					<br>
					<img src="img/navdivide.png"></img>
					<br>
					<br>
					<li><a = href="design.html">DESIGN</a></li>
					<li><a = href="implementation.html" class="disabled">IMPLEMENTATION</a></li>
					<li><a = href="testing.html">TESTING</a></li>
					<li><a = href="term2.html">FUTURE PLANS</a></li>
			</ul>
			</div>
		</div>



		<div class="main">

			<div class="content">
				<h1>Proof of Concept Implementation (TODO: HEADER IMAGE)</h1>
				<p>Due to the resources required to develop this system in its full form, we worked with hardware and wrote software to produce a subset of the final working implementation. This acts as our proof of concept for the design, and lays the foundations for the working-scale implementation we will build in term 2 (see <a = href"term2.html">Future Plans</a>). Thus, the system we have produced prototypes the following design:</p>
				<img src="img/image.jpg"/>
				<p>The sensor (a) in our system is modelled using an ultrasound distance finder connected to an Arduino Mega along with a Bluetooth transmitter. The node (b)  is simulated by a laptop; due to unfortunate circumstances, we were unable to use a Raspberry Pi as initially planned. The database (c) is hosted using Windows Azure services, and analytics (d) were carried out on a laptop rather than a virtual machine using an API we developed. We have documented the development of each element below, and a video demonstration of the system in operation can be found at the bottom of this page.</p>
			</div>

			<div class="content">
				<img src="img/hardwareproto.png"/>
	
			<p>
				To demonstrate our project, we created a prototype to show at a small scale what our system might look like. The demo itself consists of a sensor SRF05 Ultra-Sonic Range Finder , along with a  WRL-12506 Sparkfun Bluetooth Mate Silver Transmitter and an Arduino. Below is a picture of what the final device looks like:
			</p>
			<p>
				<h2>Picture of final prototype:</h2>
			</p>
			 <img src="img/Prototype.jpg" style="width:317px;height:426px" >
			<p>
				<h2>Schematics for the prototype:</h2>
			</p>
			<img src="img/PrototypeSchematics.png" style="width:600px;height:668px" >
			<h2>How it works:</h2>
			<p>
				As seen in the diagram, we have an ultrasonic sensor connected to a 5V pin, a digital pin and ground pins. This allows us to use the digital pin as both our input trigger and our output echo. In our code we set the pin to be an output pin and send a small ping to the ultrasonic sensor. We then immediately switch the pin to be an input pin that measures the duration of the signal send by the sensor. 
			</p>
			<h2>Calculating the distance based on Ultrasound reading:</h2>
			<p>
				The length of the sensor is equal to the amount of time it took for the ultrasound created by the sensor to hit a target and come back. This duration can then be converted into a centimeters distance. Since the speed of sound stays the same, we can determine what the distance is by using the below calculations:
			</p>
			<p><i>
				Speed = Distance / Time
			</i></p>
			<p><i>
				Speed of sound = 34'300 cm/s = 34.3 cm/ms
			</i></p>
			<p>
				Since the time measurement received was there and back, we want to divide the duration by 2:
			</p>
			<p><i>
				Speed = Distance / (Time/2)
			</i></p>
			<p><i>
				17.15 = Distance / Time
			</i></p>
			<p><i>
				Distance = 17.15 * Time
			</i></p>
			<p>
				This formula will convert the duration of the echo transmitted by the sensor to a centimeter distance.
			</p>
			<p>
				Once the distance has been calculated, we use the bluetooth transmitter to wirelessly transmit the data. The Bluetooth transmitter is connected to a 3.3V pin, a ground pin, a Tx (transmitting) pin and an Rx (receiving) pin. By sending data through the transmitting pin, we are able to send the data to a computer nearby. The computer is acting as our zone controller and handles uploading to the database.
			</p>
			<p>
				This prototype shows what our system will most likely do, except there will be more devices doing this. The sensor can be any sensor that returns a binary/string value so it is not limited to this example. 
			</p>
			<p><h2> Hardware Prototype Testing Results</h2></p>
			
			<p>
				From testing our hardware, we found that the ultrasound sensor was very accurate in measurements ranging from 10-200cm. 
				Anything beyond that and the readings would vary greatly from small movements.
				The below picture shows the distance measured by the ultrasonic device, compared to the actual distance:
			</p>
			</p>
			 <img src="img/UltrasoundTest.jpg" style="width:900px;height:652px" >
			<p>
			<p>
				As seen, the measurements are accurate to with a margin of error of <= 1cm. 
			</p>
			</div>

			<div class="content">
				<h1>System Prototyping (TODO new title image)</h1>
				<h2>Arduino package, modelling a roadside sensor</h2>
				<img src="img/greydot.png"/>
				<p>The sensor hardware used here is not fully representative of what might be implemented in term 2, due to the unreliability of ultrasound distance finders being used in this context. Nonetheless, the system remains the same – the node will read in data from a sensor and transmit this via Bluetooth to its parent node (a nearby wifi-enabled processor to send the data to a database).</p>
				<p>The code for the Arduino has a mostly empty loop, with a ‘serialEvent()’ function waiting to read input from the node – a request for information. The sensor will therefore take a reading if and only if a request is made to it. Consequently, the sensor will spend most of its time asleep, conserving battery life that would otherwise be spent repeatedly polling it every few milliseconds.</p>
				<p>Additionally, when preparing data, the code takes the average of 100 readings from the sensor in order to maximise the reliability of the response. This is particularly important since the next update could potentially not occur for a number of minutes.</p>
				<p>The data in this case is an integer value representing the distance, in centimetres, between the ultrasonic sensor and the next object in its line of sight. Processing on the raw reading (in order to convert it into a centimetre value) is carried out within the Arduino’s code, as detailed in the above section. Once the data is received by the main loop, it is printed through the serial port (between the Bluetooth transmitter on the sensor and the receiver in the node (or, in this case, laptop)).</p>
				<div class="code">
					<h3>const int pingPin = 22;</h3>
					<h3>byte byteRead = 3;</h3>
					<h3>long cm = -1;</h3>
					<br>
					<h3>void setup() {</h3>
					<h3><pre>  Serial.begin(115200);</h3>
					<h3>}</h3>
					<br>
					<h3>void loop()</h3>
					<h3>{</h3>
					<h3><pre>  if( cm > 0 ){</h3>
					<h3><pre>    Serial.println(cm);</h3>
					<h3><pre>    cm = -1;</h3>
					<h3><pre>  }</h3>
					<h3>}</h3>
					<br>
					<h3>void serialEvent() {</h3>
					<br>
					<h3><pre>  byteRead = Serial.read();</h3>
					<h3><pre>  long duration = 0;</h3>
					<br>
					<h3><pre>  for(int i = 0; i < 100; i++) {</h3>
					<h3><pre>    /* Read measurement from sensor */</h3>
					<h3><pre>    duration += pulseIn(pingPin, HIGH);</h3>
					<h3><pre>  }</h3>
					<br>
					<h3><pre>  duration = duration/100;</h3>
					<br>
					<h3><pre>  cm = microsecondsToCentimeters(duration);</h3>
					<h3>}</h3>
				</div>
				<br>
				<h2>Java code modelling road-side node</h2>
				<img src="img/greydot.png"/>
				<p>The communication between the sensor and the database is handled using Java. In our original plan, this prototype was intended to be developed using a Raspberry Pi, but issues sourcing the components meant that simply running the code on a laptop was necessary. The initial development of this code, without use of the API (which was built later and is detailed below), consisted of 4 primary classes:</p>
				<ul>
					<li><strong>SerialRead</strong> is the lowest-level class, and uses the library rxtxcomm.jar to communicate with the serial port on the Arduino. It first opens a connection with a BufferedReader for input and an OutputStream for sending a request. It takes a port name as a parameter, and opens a connection to that port, pinging it with a byte as a request and then reading a line into its BufferedReader. This is a string, which is then converted to an Integer.</li>
					<li><p><strong>SensorRead</strong> uses <strong>SerialRead</strong> to make a connection to a named sensor and then upload the data to the database. It takes the sensor’s ID number and string description of its associated port as parameters, and makes updates accordingly. Any given node will have one SensorRead object for each of the sensors it is connected to.</li>
					<li><strong>DatabaseConnect</strong> establishes a connection to the Azure SQL database and contains methods for submitting queries. Both <strong>SensorRead</strong> and <strong>NodeMain</strong> use its methods to submit UPDATE queries.</li>
					<br>
					<li><strong>NodeMain</strong> contains the main method, and loops indefinitely whilst calling to all of its children sensors for a reading update every minute. It has exactly one <strong>SensorRead</strong> object for each sensor it’s connected to, and is also responsible for reporting its operating status.</li>
				</ul>
				<img src="img/image.jpg" meta="UML Diagram"/>
				<br>
				<h2>Building the SQL Database</h2>
				<img src="img/greydot.png"/>
				<p>Database Stuff</p>
			</div>

			<div class="content">
				<h1>API Prototyping (TODO new title image)</h1>
				<p>This section will contain details about the development of the API and how it was used in analytics to fill the parking table of the database</p>
				<p>Assigned to: <strong>Victoria</strong></p>
			</div>

			<div class="content">
				<h1>Demonstration (TODO: HEADER IMAGE)</h1>
				<p>Video demonstration of the system in use (By Gulliver)</p>
			</div>

			<div class="contentlast">
				<img src="img/git.png"/>
				<a = href="http://github.com/GulliverJ/Group10">Click to view the project on GitHub</a>
				<p>Text about how we used GitHub... Maybe talk about setbacks.. maybe.....</p>
			</div>
		</div>

	</div>

	<div class="footer">
		<div class="title" style="float: top;">
			<p class="body" style="font-size: 10px; line-height: 3px;"> <span class="highlight" style="font-size: 10px;">Copyright (c) 2014 Group 10 </span> | Website design by Gulliver Johnson</p>
		</div>
	</div>
</body>
</html>
